# musl-test
Тестовое для проекта Kotlin/Native: musl-based target

# Использование скриптов:
## buildclang.py
`python3 buildclang.py`
Запускает `cmake` с опцией `--build`. Этого достаточно для сборки `clang`, учитывая наличие CMakeLists.

Поддерживается возможность ручного введения директории с исходниками, выбор количества потоков (по умолчанию равно количеству потоков процессора). 

Сборка при помощи уже собранного компилятора реализована в двух вариантах. Первый - мы полностью собрали компилятор, он уже у нас есть, и мы просто передаем его в качестве компилятора для сборки. Второй - bootstrap. Тут есть, опять же, несколько вариантов. Первый (редкий) - у нас нет никакого компилятора для C/C++, и нам нужно его получить. Для этого у нас могут быть исходники в виде байткода, которые соберут маленькое подобие компилятора, дальше соберется что-то большее, и еще через несколько шагов мы сможем собрать минимальный компилятор, способный собрать clang. Второй - у нас уже есть условный gcc, тогда мы сразу можем собрать clang. 


После этого с помощью собранного clang пересобрать его заново Данная операция производится в обоих случаях, это одновременно и проверка работоспособности компилятора, и избавление от возможных зависимостей.

## clang.py
`python3 clang.py args`
Все аргументы передаются напрямую системному clang. Для того, чтобы скомпилированная программа выводила в `stdin` дату и время компиляции было решено использовать, наверное, не очень хорошую, но рабочую схему:
1. Создаем небольшой файлик, который всегда выводит дату и время.
2. Насильно включаем его в каждую сборку.

Что плохо? Возможные конлфикты имен - для константы `PRINT_COMPILE_DATETIME` и для названия глобального класса.

# Ответы на вопросы:
1. В чем профит от сборки компилятора самим собой? Компилятор - сложная система с очень большим количеством возможных настроек. При самостоятельной сборке можно включить те возможности, которые в стандартной сборке не представлены. Можно так же проверить результат сборки.
2. Как ускорить процесс сборки? Из того, что доступно на локальной машине с исходниками, в которых не хочется копаться: Собирать в несколько потоков, использовать предкомпиляцию заголовков. Если машин несколько, то сборку можно распараллелить между ними. А еще, в теории, можно билдить Debug-версию (она будет больше в размере и менее оптимизированной, но оптимизации замедляют компиляцию. Хотя гарантии тут давать сложно, все сильно зависит от конкретного проекта).
